<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Diagnosing YARP-based proxies </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Diagnosing YARP-based proxies ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="diagnosing-yarp-based-proxies">Diagnosing YARP-based proxies</h1>

<p>When using a reverse proxy, there is an additional hop from the client to the proxy, and then from the proxy to destination for things to go wrong. This topic should provide some hints and tips for how to debug and diagnose issues when they occur. It assumes that the proxy is already running, and so does not include problems at startup such as configuration errors.</p>
<h2 id="logging">Logging</h2>
<p>The first step to being able to tell what is going on with YARP is to turn on <a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/#configure-logging">logging</a>. This is a configuration flag so can be changed on the fly. YARP is implemented as a middleware component for ASP.NET Core, so you need to enable logging for both YARP and ASP.NET to get the complete picture of what is going on.</p>
<p>By default ASP.NET will log to the console, and the configuration file can be used to control the level of logging.</p>
<pre><code class="lang-Json">  //Sets the Logging level for ASP.NET
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      // Uncomment to hide diagnostic messages from runtime and proxy
      // &quot;Microsoft&quot;: &quot;Warning&quot;,
      // &quot;Yarp&quot; : &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  },
</code></pre>
<p>You want logging infomation from the &quot;Microsoft.AspNetCore.<em>&quot; and &quot;Yarp.ReverseProxy.</em>&quot; providers. The example above will emit &quot;Information&quot; level events from both providers to the Console. Changing the level to &quot;Debug&quot; will show additional entries. ASP.NET implements change detection for configuration files, so you can edit the appsettings.json file (or appsettings.development.json if running from Visual Studio) while the project is running and observe changes to the log output.</p>
<h3 id="understanding-log-entries">Understanding Log entries</h3>
<p>The logging output is directly tied to the way that ASP.NET Core processes requests. It's important to realize that as middleware, YARP is relying on much of the ASP.NET functionality to process the requests, for example the following is for the processing of a request with &quot;Debug&quot; mode enabled:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Log Message</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Connections[39]<br>Connection id &quot;0HMCD0JK7K51U&quot; accepted.</td>
<td>Connections are independent of requests, so this is a new connection</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Connections[1]<br>Connection id &quot;0HMCD0JK7K51U&quot; started.</td>
<td></td>
</tr>
<tr>
<td>info</td>
<td>Microsoft.AspNetCore.Hosting.Diagnostics[1]<br>Request starting HTTP/1.1 GET http://localhost:5000/ - -</td>
<td>This is the incomming request to ASP.NET</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.HostFiltering.HostFilteringMiddleware[0]<br>Wildcard detected, all requests with hosts will be allowed.</td>
<td>My configuation does not tie endpoints to specific hostnames</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Routing.Matching.DfaMatcher[1001]<br>1 candidate(s) found for the request path '/'</td>
<td>This shows what possible matches there are for the route</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Routing.Matching.DfaMatcher[1005]<br>      Endpoint 'minimumroute' with route pattern '{**catch-all}' is valid for the request path '/'</td>
<td>The mimimum route from YARPs configuration has matched</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware[1]<br>     Request matched endpoint 'minimumroute'</td>
<td></td>
</tr>
<tr>
<td>info</td>
<td>Microsoft.AspNetCore.Routing.EndpointMiddleware[0]<br>      Executing endpoint 'minimumroute'</td>
<td></td>
</tr>
<tr>
<td>info</td>
<td>Yarp.ReverseProxy.Forwarder.HttpForwarder[9]<br>      Proxying to <a href="http://www.example.com/">http://www.example.com/</a></td>
<td>YARP is proxying the request to example.com</td>
</tr>
<tr>
<td>info</td>
<td>Microsoft.AspNetCore.Routing.EndpointMiddleware[1]<br>      Executed endpoint 'minimumroute'</td>
<td></td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Connections[9]<br>      Connection id &quot;0HMCD0JK7K51U&quot; completed keep alive response.</td>
<td>The response has finished, but connection can be kept alive.</td>
</tr>
<tr>
<td>info</td>
<td>Microsoft.AspNetCore.Hosting.Diagnostics[2]<br>Request finished HTTP/1.1 GET http://localhost:5000/ - - - 200 1256 text/html;+charset=utf-8 12.7797ms</td>
<td>The response completed with status code 200, responding with 1256 bytes as text/html in ~13ms.</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets[6]<br>      Connection id &quot;0HMCD0JK7K51U&quot; received FIN.</td>
<td>Diagnostic information about the connection to determine who closed it and how cleanly</td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Connections[10]<br>      Connection id &quot;0HMCD0JK7K51U&quot; disconnecting.</td>
<td></td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Connections[2]<br>      Connection id &quot;0HMCD0JK7K51U&quot; stopped.</td>
<td></td>
</tr>
<tr>
<td>dbug</td>
<td>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets[7]<br>      Connection id &quot;0HMCD0JK7K51U&quot; sending FIN because: &quot;The Socket transport's send loop completed gracefully.&quot;</td>
<td></td>
</tr>
</tbody>
</table>
<p>The above gives general information about the request and how it was processed.</p>
<h3 id="using-aspnet-6-request-logging">Using ASP.NET 6 Request Logging</h3>
<p>If running on .NET 6, then ASP.NET includes an additional middleware component that can be used to provide more details about the request and response. The <code>UseHttpLogging</code> component can be added to the request pipeline. It will add additional entries to the log detailing the incoming and outgoing request headers.</p>
<pre><code class="lang-C#">// This method gets called by the runtime. Use this method to configure the HTTP request 
// pipeline that handles requests
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseHttpLogging();
    // Enable endpoint routing, required for the reverse proxy
    app.UseRouting();
    // Register the reverse proxy routes
    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapReverseProxy();
    });
}
</code></pre>
<p>For example:</p>
<pre><code class="lang-Console">info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]
      Request:
      Protocol: HTTP/1.1
      Method: GET
      Scheme: http
      PathBase:
      Path: /
      Accept: */*
      Host: localhost:5000
      User-Agent: curl/7.55.1
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]
      Response:
      StatusCode: 200
      Content-Type: text/html; charset=utf-8
      Date: Tue, 12 Oct 2021 23:29:20 GMT
      Server: ECS,(sec/97A5)
      Age: 113258
      Cache-Control: [Redacted]
      ETag: [Redacted]
      Expires: Tue, 19 Oct 2021 23:29:20 GMT
      Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
      Vary: [Redacted]
      Content-Length: 1256
      X-Cache: [Redacted]
</code></pre>
<h2 id="using-telemetry-events">Using Telemetry Events</h2>
<p>The <a href="https://github.com/microsoft/reverse-proxy/tree/main/samples/ReverseProxy.Metrics.Sample">Metrics sample</a> shows how to listen to events from the different providers that collect telemetry as part of YARP. The most important from a diagnostics perspective are:</p>
<ul>
<li>ForwarderTelemetryConsumer</li>
<li>HttpClientTelemetryConsumer</li>
</ul>
<p>To use either of these you create a class implementing a <a href="https://microsoft.github.io/reverse-proxy/api/Yarp.Telemetry.Consumption.html#interfaces">telemetry interface</a>, such as <a href="https://github.com/microsoft/reverse-proxy/blob/release/latest/src/TelemetryConsumption/Forwarder/IForwarderTelemetryConsumer.cs"><code>IForwarderTelemetryConsumer</code></a>:</p>
<pre><code class="lang-C#">public class ForwarderTelemetry : IForwarderTelemetryConsumer
{

      /// Called before forwarding a request.
      public void OnForwarderStart(DateTime timestamp, string destinationPrefix)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnForwarderStart :: Destination prefix: {destinationPrefix}&quot;);
      }

      /// Called after forwarding a request.
      public void OnForwarderStop(DateTime timestamp, int statusCode)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnForwarderStop :: Status: {statusCode}&quot;);
      }

      /// Called before &lt;see cref=&quot;OnForwarderStop(DateTime, int)&quot;/&gt; if forwarding the request failed.
      public void OnForwarderFailed(DateTime timestamp, ForwarderError error)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnForwarderFailed :: Error: {error.ToString()}&quot;);
      }

      /// Called when reaching a given stage of forwarding a request.
      public void OnForwarderStage(DateTime timestamp, ForwarderStage stage)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnForwarderStage :: Stage: {stage.ToString()}&quot;);
      }

      /// Called periodically while a content transfer is active.
      public void OnContentTransferring(DateTime timestamp, bool isRequest, long contentLength, long iops, TimeSpan readTime, TimeSpan writeTime)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnContentTransferring :: Is request: {isRequest}, Content length: {contentLength}, IOps: {iops}, Read time: {readTime:s\\.fff}, Write time: {writeTime:s\\.fff}&quot;);
      }

        /// Called after transferring the request or response content.
      public void OnContentTransferred(DateTime timestamp, bool isRequest, long contentLength, long iops, TimeSpan readTime, TimeSpan writeTime, TimeSpan firstReadTime)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnContentTransferred :: Is request: {isRequest}, Content length: {contentLength}, IOps: {iops}, Read time: {readTime:s\\.fff}, Write time: {writeTime:s\\.fff}&quot;);
      }

      /// Called before forwarding a request from `ForwarderMiddleware`, therefore is not called for direct forwarding scenarios.
      public void OnForwarderInvoke(DateTime timestamp, string clusterId, string routeId, string destinationId)
      {
            Console.WriteLine($&quot;Forwarder Telemetry [{timestamp:HH:mm:ss.fff}] =&gt; OnForwarderInvoke:: Cluster id: {clusterId}, Route Id: { routeId}, Destination: {destinationId}&quot;);
      }
}
</code></pre>
<p>And then register the class as part of <code>Configure Services</code>, for example:</p>
<pre><code class="lang-C#">public void ConfigureServices(IServiceCollection services)
{
      services.AddTelemetryConsumer&lt;ForwarderTelemetry&gt;();

      // Add the reverse proxy to capability to the server
      var proxyBuilder = services.AddReverseProxy();
      // Initialize the reverse proxy from the &quot;ReverseProxy&quot; section of configuration
      proxyBuilder.LoadFromConfig(Configuration.GetSection(&quot;ReverseProxy&quot;));
}
</code></pre>
<p>Then you will log details on each part of the request, for example:</p>
<pre><code class="lang-Console">Forwarder Telemetry [06:40:48.186] =&gt; OnForwarderInvoke:: Cluster id: minimumcluster, Route Id: minimumroute, Destination: example.com
Forwarder Telemetry [06:41:00.269] =&gt; OnForwarderStart :: Destination prefix: http://www.example.com/
Forwarder Telemetry [06:41:00.298] =&gt; OnForwarderStage :: Stage: SendAsyncStart
Forwarder Telemetry [06:41:00.507] =&gt; OnForwarderStage :: Stage: SendAsyncStop
Forwarder Telemetry [06:41:00.530] =&gt; OnForwarderStage :: Stage: ResponseContentTransferStart
Forwarder Telemetry [06:41:03.655] =&gt; OnForwarderStop :: Status: 200
</code></pre>
<p>The events for Telemetry are fired as they occur, so you can <a href="https://docs.microsoft.com/aspnet/core/fundamentals/http-context#use-httpcontext-from-custom-components">fish out the HttpContext</a> and the YARP feature from it:</p>
<pre><code class="lang-C#">public void ConfigureServices(IServiceCollection services)
{
      services.AddTelemetryConsumer&lt;ForwarderTelemetry&gt;();
      services.AddHttpContextAccessor();
      ...
}

public void OnForwarderInvoke(DateTime timestamp, string clusterId, string routeId, string destinationId)
{
      var context = new HttpContextAccessor().HttpContext;
      var YarpFeature = context.GetReverseProxyFeature();

      var dests = from d in YarpFeature.AvailableDestinations
            select d.Model.Config.Address;

      Console.WriteLine($&quot;Destinations: {string.Join(&quot;, &quot;, dests)}&quot;);
}
</code></pre>
<h2 id="using-custom-middleware">Using custom middleware</h2>
<p>Another way to inspect the state for requests is to insert additional middleware into the request pipeline. You can insert between the other stages to see the state of the request.</p>
<pre><code class="lang-C#">public void Configure(IApplicationBuilder app)
{
      app.UseRouting();
      app.UseEndpoints(endpoints =&gt;
      {
            // We can customize the proxy pipeline and add/remove/replace steps
            endpoints.MapReverseProxy(proxyPipeline =&gt;
            {
                  // Use a custom proxy middleware, defined below
                  proxyPipeline.Use(MyCustomProxyStep);
                  // Don't forget to include these two middleware when you make a custom proxy pipeline (if you need them).
                  proxyPipeline.UseSessionAffinity();
                  proxyPipeline.UseLoadBalancing();
            });
      });
}

public Task MyCustomProxyStep(HttpContext context, Func&lt;Task&gt; next)
{
      // Can read data from the request via the context
      foreach (var header in context.Request.Headers)
      {
            Console.WriteLine($&quot;{header.Key}: {header.Value}&quot;);
      }

      // The context also stores a ReverseProxyFeature which holds proxy specific data such as the cluster, route and destinations
      var proxyFeature = context.GetReverseProxyFeature();
      Console.WriteLine(System.Text.Json.JsonSerializer.Serialize(proxyFeature.Route.Config));

      // Important - required to move to the next step in the proxy pipeline
      return next();
}
</code></pre>
<p>You can also use <a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/write">ASP.NET middleware</a> within Configure that will enable you to inspect the request before the proxy pipeline.</p>
<blockquote>
<p><strong>Note:</strong> The proxy will stream the response from the destination server back to the client, so the response headers and body are not readily accessible via middleware.</p>
</blockquote>
<h2 id="using-the-debugger">Using the debugger</h2>
<p>A debugger, such as Visual Studio can be attached to the proxy process. However, unless you have existing middleware, there is not a good place in the app code to break and inspect the state of the request. Therefore the debugger is best used in conjunction with one of the techniques above so that you have distinct places to insert breakpoints etc.</p>
<h2 id="network-tracing">Network Tracing</h2>
<p>It can be attractive to use network tracing tools like <a href="https://www.telerik.com/fiddler">Fiddler</a> or <a href="https://www.wireshark.org/">Wireshark</a> to try to monitor what is happening either side of the proxy. However there are some gotchas to using both tools.</p>
<ul>
<li>Fiddler registers itself as a proxy and relies on applications using the default proxy to be able to monitor traffic. This works for inbound traffic from a browser to YARP, but will not capture the outbound requests as YARP is configured to not use the proxy settings for outbound traffic.</li>
<li>On windows Wireshark uses Npcap to capture packet data for network traffic, so it will capture both inbound and outbound traffic, and can be used to monitor HTTP traffic. Wireshark works out of the box for HTTP traffic.</li>
<li>HTTPS traffic is encrypted, and so is not automatically decryptable by network monitoring tools. Each tool has workarounds that may enable traffic to be monitored, but they require hacking around with certificates and trust relationships. Because YARP is making outbound requests, techniques for tricking browsers do not apply to the YARP process.</li>
</ul>
<p>The protocol choice for outbound traffic is made based on the destination URL in the cluster configuration. If traffic monitoring is being used for diagnostics then, if possible, changing the outbound URLs to &quot;http://&quot; may be simplest approach to enable the monitoring tools to work, provided the issues being diagnosed are not transport protocol related.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/reverse-proxy/blob/release/latest/docs/docfx/articles/diagnosing-yarp-issues.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
